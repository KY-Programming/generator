// ------------------------------------------------------------------------------
//  <auto-generated>
//      This code was generated with KY.Generator 6.1.0.0
//      Manual changes to this file may cause unexpected behavior in your application.
//      Manual changes to this file will be overwritten if the code is regenerated.
//  </auto-generated>
// ------------------------------------------------------------------------------
// tslint:disable

import { ConnectionStatus } from "../models/connection-status";
import { WeatherForecast } from "../models/weather-forecast";
import { Injectable } from "@angular/core";
import { HubConnection } from "@aspnet/signalr";
import { HubConnectionBuilder } from "@aspnet/signalr";
import { HubConnectionState } from "@aspnet/signalr";
import { Observable } from "rxjs";
import { of } from "rxjs";
import { flatMap } from "rxjs/operators";
import { ReplaySubject } from "rxjs";
import { Subject } from "rxjs";

@Injectable({
    providedIn: "root"
})
export class WeatherHubService {
    public serviceUrl: string = "";
    private connection: HubConnection;
    private readonly timeouts: number[] = [0, 0, 1000, 2000, 5000];
    private readonly statusSubject: ReplaySubject<ConnectionStatus> = new ReplaySubject<ConnectionStatus>(1);
    public readonly status$: Observable<ConnectionStatus> = this.statusSubject.asObservable();
    private readonly updatedSubject: Subject<WeatherForecast[]> = new Subject<WeatherForecast[]>();
    public readonly updated$: Observable<WeatherForecast[]> = this.updatedSubject.asObservable();

    public connect(trial: number = 0): Observable<void> {
        if (! this.serviceUrl) {
            throw new Error("serviceUrl can not be empty. Set it via service.serviceUrl.")
        }
        if (! this.connection) {
            this.connection = new HubConnectionBuilder().withUrl(this.serviceUrl).build();
            this.connection.onclose(() => {
                this.statusSubject.next(ConnectionStatus.connecting);
                this.connect()
            });
            this.connection.on("Updated", (forecast: WeatherForecast[]) => {
                this.updatedSubject.next(forecast);
            });
        }
        if (this.connection.state === HubConnectionState.Connected) {
            return of(undefined);
        }
        this.statusSubject.next(ConnectionStatus.connecting);
        let subject = new Subject<void>();
        this.connection.start().then(() => {
            subject.next();
            subject.complete();
            this.statusSubject.next(ConnectionStatus.connected);
        }).catch((error) => {
            this.statusSubject.next(ConnectionStatus.disconnected);
            let timeout: number = this.timeouts[trial];
            timeout = timeout || this.timeouts[this.timeouts.length - 1] || 0;
            setTimeout(() => this.connect(trial + 1).subscribe(() => {
                subject.next();
                subject.complete();
            }, (innerError) => subject.error(innerError)), timeout);
        });
        return subject;
    }

    public fetch(): Observable<void> {
        let subject = new Subject<void>();
        this.connect().pipe(flatMap(() => this.connection.send("Fetch"))).subscribe(() => {
            subject.next();
            subject.complete();
        }, (error) => subject.error(error));
        return subject;
    }
}

// outputid:6be9fb0d-f8bf-4b07-957c-6a66a127ac63
